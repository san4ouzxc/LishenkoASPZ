# Практична робота №8
# Лiшенко О.Д.
## Варiант 11

## Завдання 1

Чи може виклик `count = write(fd, buffer, nbytes)`; повернути в змінній count значення, відмінне від `nbytes`? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

### Виконання:

У цьому прикладі демонструється ситуація, коли системний виклик `write()` не записує одразу всі `nbytes`, а повертає менше значення — частковий запис. Це можливо, наприклад, при записі в неблокуючий `FIFO`, сокет, або при переповненні буфера. Програма наочно показує, що `count != nbytes` - це нормальна ситуація в деяких випадках.

``` 
lilpeep@avice:~/pw8 $ gcc -Wall 1.c -o 1
lilpeep@avice:~/pw8 $ ./1
write: Resource temporarily unavailable
Total written before partial write: 65536 bytes
lilpeep@avice:~/pw8 $ 
```

## Завдання 2

Є файл, дескриптор якого — `fd`. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
`lseek(fd, 3, SEEK_SET)`;
`read(fd, &buffer, 4)`;
де виклик `lseek` переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.


### Виконання:

Програма відкриває файл, де записано 10 байтів. Команда `lseek(fd, 3, SEEK_SET)` встановлює позицію читання на 4-й байт (рахується з нуля). Після цього `read(fd, &buffer, 4)` читає 4 байти, починаючи з 3-го. Тобто, зчитані значення — це 2, 3, 3, 7.

``` 
lilpeep@avice:~/pw8 $ gcc -Wall 2.c -o 2
lilpeep@avice:~/pw8 $ ./2
Read 4 bytes:
Byte 0: 2
Byte 1: 3
Byte 2: 3
Byte 3: 7
lilpeep@avice:~/pw8 $ 
```

## Завдання 3

Бібліотечна функція `qsort` призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з `qsort` кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу `void*` на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.


Придумайте і реалізуйте набір тестів для перевірки правильності функції `qsort`.


### Виконання:

Програма генерує кілька типів масивів (вже відсортований, у зворотному порядку, з однаковими значеннями, випадковий, бінарний) і вимірює, скільки часу `qsort()` витрачає на сортування кожного з них. Це дозволяє виявити типи даних, на яких алгоритм працює найповільніше. Результати показують, що найменше часу займає сортування вже впорядкованих або однакових елементів, а найбільше — випадкових і бінарних.


``` 
lilpeep@avice:~/pw8 $ gcc -Wall 3.c -o 3
lilpeep@avice:~/pw8 $ ./3
QSort performance test on 100000 elements
-----------------------------------------
Pattern: sorted     | Time: 0.0000 sec | Sorted: YES
Pattern: reversed   | Time: 0.0000 sec | Sorted: YES
Pattern: random     | Time: 0.0078 sec | Sorted: YES
Pattern: identical  | Time: 0.0000 sec | Sorted: YES
Pattern: binary     | Time: 0.0078 sec | Sorted: YES
lilpeep@avice:~/pw8 $ 

```

## Завдання 4

Виконайте наступну програму на мові програмування С:

```
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
```

Завершіть цю програму. Припускаючи, що виклик `fork()` був успішним, яким може бути результат виконання цієї програми?


### Виконання:

Якщо виклик `fork()` був успішним, то створюються два процеси: батьківський і дочірній.
У батьківському процесі `fork()` повертає `PID` дочірнього процесу — це додатне число.


У дочірньому процесі `fork()` повертає 0.


Команда `printf("%d\n", pid)`; буде виконана в обох процесах, тому на екрані з’явиться два рядки:
один із числом 0 (від дочірнього процесу),


інший — з додатним числом (від батьківського процесу).


Порядок виводу не визначений — спочатку може надрукуватися або 0, або `PID`.

``` 
lilpeep@avice:~/pw8 $ gcc -Wall 4.c -o 4
lilpeep@avice:~/pw8 $ ./4
I am process with pid: 2116, fork() returned: 2117
lilpeep@avice:~/pw8 $ I am process with pid: 2117, fork() returned: 0

```



## Завдання по варiанту 11

Зробіть самостійну реалізацію `qsort()` і порівняйте її поведінку з системною на масиві об’єктів з нестабільним порівнянням.


### Виконання:

Тут реалізовано власну функцію сортування (наприклад, `Quicksort`) і порівнюється її поведінка з `qsort()` із стандартної бібліотеки. Масив структур має однакові ключі, але різні `original_position`. Порівняння демонструє, що системна `qsort()` може бути стабільною або нестабільною залежно від реалізації, а власну можна адаптувати під стабільну поведінку. Це важливо при сортуванні складних об'єктів, де порядок рівнозначних елементів має значення.

``` 
lilpeep@avice:~/pw8 $ gcc -Wall 11.c -o 11
lilpeep@avice:~/pw8 $ ./11
Original:
  { key: 5, pos: 0 }
  { key: 2, pos: 1 }
  { key: 5, pos: 2 }
  { key: 2, pos: 3 }
  { key: 5, pos: 4 }

System qsort:
  { key: 2, pos: 1 }
  { key: 2, pos: 3 }
  { key: 5, pos: 0 }
  { key: 5, pos: 2 }
  { key: 5, pos: 4 }

My qsort:
  { key: 2, pos: 3 }
  { key: 2, pos: 1 }
  { key: 5, pos: 4 }
  { key: 5, pos: 0 }
  { key: 5, pos: 2 }

lilpeep@avice:~/pw8 $ 


```



